#include <yaul.h>
#include "scsp.h"
#include "ken.raw.h"
#include "midi/midi-parser.h"
#include "dbg.h"
#include "mml_parser.h"

#include "mod/modplay.h"
#include "mkmod.h"
#include "space_d.h"
#include "unreal.h"
#include "elysium.h"

// a4
// 440hz
const unsigned char note_a4[] = {
    0x40, 0x00, 0x48, 0x0A, 0x50, 0x0B, 0x57, 0xFC, 0x5F, 0xD5, 0x67, 0x8E,
    0x6F, 0x1F, 0x76, 0x80, 0x7D, 0xAA, 0x84, 0x96, 0x8B, 0x3D, 0x91, 0x97,
    0x97, 0x9F, 0x9D, 0x4F, 0xA2, 0xA0, 0xA7, 0x8E, 0xAC, 0x13, 0xB0, 0x2B,
    0xB3, 0xD1, 0xB7, 0x03, 0xB9, 0xBC, 0xBB, 0xFB, 0xBD, 0xBC, 0xBE, 0xFE,
    0xBF, 0xBF, 0xBF, 0xFF, 0xBF, 0xBF, 0xBE, 0xFE, 0xBD, 0xBC, 0xBB, 0xFB,
    0xB9, 0xBC, 0xB7, 0x03, 0xB3, 0xD1, 0xB0, 0x2B, 0xAC, 0x13, 0xA7, 0x8E,
    0xA2, 0xA0, 0x9D, 0x4F, 0x97, 0x9F, 0x91, 0x97, 0x8B, 0x3D, 0x84, 0x96,
    0x7D, 0xAA, 0x76, 0x80, 0x6F, 0x1F, 0x67, 0x8E, 0x5F, 0xD5, 0x57, 0xFC,
    0x50, 0x0B, 0x48, 0x0A, 0x40, 0x00, 0x37, 0xF6, 0x2F, 0xF5, 0x28, 0x04,
    0x20, 0x2B, 0x18, 0x72, 0x10, 0xE1, 0x09, 0x80, 0x02, 0x56, 0xFB, 0x6A,
    0xF4, 0xC3, 0xEE, 0x69, 0xE8, 0x61, 0xE2, 0xB1, 0xDD, 0x60, 0xD8, 0x72,
    0xD3, 0xED, 0xCF, 0xD5, 0xCC, 0x2F, 0xC8, 0xFD, 0xC6, 0x44, 0xC4, 0x05,
    0xC2, 0x44, 0xC1, 0x02, 0xC0, 0x41, 0xC0, 0x00, 0xC0, 0x41, 0xC1, 0x02,
    0xC2, 0x44, 0xC4, 0x05, 0xC6, 0x44, 0xC8, 0xFD, 0xCC, 0x2F, 0xCF, 0xD5,
    0xD3, 0xED, 0xD8, 0x72, 0xDD, 0x60, 0xE2, 0xB1, 0xE8, 0x61, 0xEE, 0x69,
    0xF4, 0xC3, 0xFB, 0x6A, 0x02, 0x56, 0x09, 0x80, 0x10, 0xE1, 0x18, 0x72,
    0x20, 0x2B, 0x28, 0x04, 0x2F, 0xF5, 0x37, 0xF6};

const unsigned char note_c4[] = {
    0xFB, 0xFF, 0xF6, 0xFF, 0xF2, 0xFF, 0xED, 0xFF, 0xE8, 0xFF, 0xE4, 0xFF,
    0xDF, 0xFF, 0xDA, 0xFF, 0xD6, 0xFF, 0xD1, 0xFF, 0xCD, 0xFF, 0xC8, 0xFF,
    0xC4, 0xFF, 0xC0, 0xFF, 0xBC, 0xFF, 0xB8, 0xFF, 0xB4, 0xFF, 0xB0, 0xFF,
    0xAD, 0xFF, 0xA9, 0xFF, 0xA5, 0xFF, 0xA2, 0xFF, 0x9F, 0xFF, 0x9C, 0xFF,
    0x99, 0xFF, 0x96, 0xFF, 0x94, 0xFF, 0x91, 0xFF, 0x8F, 0xFF, 0x8D, 0xFF,
    0x8B, 0xFF, 0x89, 0xFF, 0x87, 0xFF, 0x86, 0xFF, 0x84, 0xFF, 0x83, 0xFF,
    0x82, 0xFF, 0x81, 0xFF, 0x81, 0xFF, 0x80, 0xFF, 0x80, 0xFF, 0x80, 0xFF,
    0x80, 0xFF, 0x80, 0xFF, 0x81, 0xFF, 0x81, 0xFF, 0x82, 0xFF, 0x83, 0xFF,
    0x84, 0xFF, 0x86, 0xFF, 0x87, 0xFF, 0x89, 0xFF, 0x8B, 0xFF, 0x8D, 0xFF,
    0x8F, 0xFF, 0x91, 0xFF, 0x94, 0xFF, 0x96, 0xFF, 0x99, 0xFF, 0x9C, 0xFF,
    0x9F, 0xFF, 0xA2, 0xFF, 0xA5, 0xFF, 0xA9, 0xFF, 0xAD, 0xFF, 0xB0, 0xFF,
    0xB4, 0xFF, 0xB8, 0xFF, 0xBC, 0xFF, 0xC0, 0xFF, 0xC4, 0xFF, 0xC8, 0xFF,
    0xCD, 0xFF, 0xD1, 0xFF, 0xD6, 0xFF, 0xDA, 0xFF, 0xDF, 0xFF, 0xE4, 0xFF,
    0xE8, 0xFF, 0xED, 0xFF, 0xF2, 0xFF, 0xF6, 0xFF, 0xFB, 0xFF, 0x00, 0x00,
    0x05, 0x00, 0x0A, 0x00, 0x0E, 0x00, 0x13, 0x00, 0x18, 0x00, 0x1C, 0x00,
    0x21, 0x00, 0x26, 0x00, 0x2A, 0x00, 0x2F, 0x00, 0x33, 0x00, 0x38, 0x00,
    0x3C, 0x00, 0x40, 0x00, 0x44, 0x00, 0x48, 0x00, 0x4C, 0x00, 0x50, 0x00,
    0x53, 0x00, 0x57, 0x00, 0x5B, 0x00, 0x5E, 0x00, 0x61, 0x00, 0x64, 0x00,
    0x67, 0x00, 0x6A, 0x00, 0x6C, 0x00, 0x6F, 0x00, 0x71, 0x00, 0x73, 0x00,
    0x75, 0x00, 0x77, 0x00, 0x79, 0x00, 0x7A, 0x00, 0x7C, 0x00, 0x7D, 0x00,
    0x7E, 0x00, 0x7F, 0x00, 0x7F, 0x00, 0x7F, 0x00, 0x7F, 0x00, 0x7F, 0x00,
    0x7F, 0x00, 0x7F, 0x00, 0x7F, 0x00, 0x7F, 0x00, 0x7E, 0x00, 0x7D, 0x00,
    0x7C, 0x00, 0x7A, 0x00, 0x79, 0x00, 0x77, 0x00, 0x75, 0x00, 0x73, 0x00,
    0x71, 0x00, 0x6F, 0x00, 0x6C, 0x00, 0x6A, 0x00, 0x67, 0x00, 0x64, 0x00,
    0x61, 0x00, 0x5E, 0x00, 0x5B, 0x00, 0x57, 0x00, 0x53, 0x00, 0x50, 0x00,
    0x4C, 0x00, 0x48, 0x00, 0x44, 0x00, 0x40, 0x00, 0x3C, 0x00, 0x38, 0x00,
    0x33, 0x00, 0x2F, 0x00, 0x2A, 0x00, 0x26, 0x00, 0x21, 0x00, 0x1C, 0x00,
    0x18, 0x00, 0x13, 0x00, 0x0E, 0x00, 0x0A, 0x00, 0x05, 0x00, 0x00, 0x00};

mml_parser_ctx_t mml;

int en = 0;
static void toneCallback(void *ud, uint8_t note, uint8_t oct, uint8_t length, uint8_t trk, uint8_t vol)
{
    volatile scsp_slot_regs_t *slots = get_scsp_slot(0);

    if (note == NOTE_REST)
    {
        slots->kyonb = 0;
        slots->kyonex = 0;

        en = 0;
    }
    else
    {
        if (en == 0)
        {
            slots->kyonb = 1;
            slots->kyonex = 1;
        }

        en = 1;
        uint16_t fns[] = {
            0, 300, 400, 500, 600, 700, 800, 900, 1000, 1100, 0, 100, 200};

        switch (note)
        {
        case NOTE_REST:
            break;
        case NOTE_C:
        case NOTE_CS:
        case NOTE_D:
        case NOTE_DS:
        case NOTE_E:
        case NOTE_F:
        case NOTE_FS:
        case NOTE_G:
        case NOTE_GS:
        case NOTE_A:
        case NOTE_AS:
        case NOTE_B:
            // slots->fns = fns[note];
            slots->fns = (note - 1) * 100;
            break;
        }

        slots->oct = oct - 4;
        slots->total_l = vol; // 0xff - vol;
    }
}

void memcpy_le16(uint16_t *dst, uint16_t *src, size_t sz)
{
    for (size_t i = 0; i < (sz / 2); i++)
    {
        *dst++ = __builtin_bswap32(*src++);
    }
}

static void mml_handler()
{
    if (mml_parser_play(&mml) == -1)
    {
        mml_parser_reset(&mml);
    }
}
#if 0
void midi_init()
{

    uint32_t note_c4_addr = (0x2000);

    volatile uint16_t *control = (uint16_t *)0x25b00400;
    volatile uint16_t *intr = (uint16_t *)0x25b0042a;
    control[0] = 0xf; // master vol
    intr[0] = 0;      // irq

    volatile scsp_slot_regs_t *slots = get_scsp_slot(0);

    memcpy(SCSP_RAM + note_c4_addr, note_c4, sizeof(note_c4));

    for (int i = 0; i < 32; i++)
    {
        scsp_slot_regs_t slot = {};
        memset(&slot, 0, sizeof(scsp_slot_regs_t));

        //
        slot.sa = note_c4_addr;
        slot.lsa = 0;
        slot.lea = sizeof(note_c4);

        // uned 16 bit
        slot.pcm8b = 1;
        slot.sbctl = 0;

        slot.lpctl = 1;
        slot.attack_rate = 31;
        slot.release_r = 31;
        slot.loop_start = 1;
        slot.kr_scale = 0;
        slot.sdir = 0;
        slot.disdl = 7;
        slot.total_l = 0;
        slot.efsdl = 0;

        slot.fns = 0;
        slot.oct = 0;

        slot.kyonb = 0;
        slot.kyonex = 0;

        // memcpy(&slots[i], 0, sizeof(scsp_slot_regs_t));
        for (int r = 0; r < 16; r++)
        {
            slots[i].raw[r] = slot.raw[r];
        }
    }

    // mml_parser_init(&mml, "T60 L8 CDEC. r CDEC. r EFG. r EFG. r GAGFEC. r GAGFEC. r L4 C<A>C. r C<A>C.");
    mml_parser_init(&mml, "T160 l16 o6 c e f a e f a >c <f a >c e <a >c e f <d f g b f g b >d <g b >d f <b >d f g <d f g+b f g+b >d <g+b >d f <b >d f g+<c e g a e g a >c <g a >c e <a >c e g a+a f d a f d <a+>f d <a+a >d <a+a f a+f a a+>d <a a+>d f <a+>d f a d f a bafd afd<b >fd<ba >d<bafeg+b>d <g+b>de <b>deg+ deg+b");
    mml.ud = NULL;
    mml.toneCallback = toneCallback;

    vdp_sync_vblank_in_set(mml_handler, NULL);

    // cpu_frt_init(CPU_FRT_CLOCK_DIV_128);
    // cpu_frt_oca_set(CPU_FRT_NTSC_352_128_COUNT_1MS, mml_handler);
    // cpu_frt_interrupt_priority_set(8);

    while (1)
        ;
}
#elif 1

ModMusic *mod;

static void mod_handler()
{
    int t = 1;

    MODPlay(mod, &t);
}
void midi_init()
{

    uint32_t note_c4_addr = (0x2000);

    volatile uint16_t *control = (uint16_t *)0x25b00400;
    volatile uint16_t *intr = (uint16_t *)0x25b0042a;
    control[0] = 0xf; // master vol
    intr[0] = 0;      // irq

    volatile scsp_slot_regs_t *slots = get_scsp_slot(0);

    memcpy(SCSP_RAM + note_c4_addr, note_c4, sizeof(note_c4));

    for (int i = 0; i < 32; i++)
    {
        scsp_slot_regs_t slot = {};
        memset(&slot, 0, sizeof(scsp_slot_regs_t));

        //
        slot.sa = note_c4_addr;
        slot.lsa = 0;
        slot.lea = note_c4_addr + sizeof(note_c4);

        // uned 16 bit
        slot.pcm8b = 1;
        slot.sbctl = 0;
        slot.ssctl = 0;

        slot.lpctl = 0;
        slot.attack_rate = 31;
        slot.release_r = 31;
        slot.loop_start = 0;
        slot.kr_scale = 0;
        slot.sdir = 1;
        slot.disdl = 7;
        slot.total_l = 0;
        slot.efsdl = 0;

        slot.fns = 0;
        slot.oct = 0;

        slot.kyonb = 0;
        slot.kyonex = 0;

        // memcpy(&slots[i], 0, sizeof(scsp_slot_regs_t));
        for (int r = 0; r < 16; r++)
        {
            slots[i].raw[r] = slot.raw[r];
        }
    }

    emu_printf("MODLoad\n");
    mod = MODLoad(ELYSIUM);
    // mod = MODLoad(space_d);
    // mod = MODLoad(mkmod);
    // mod = MODLoad(unreal_pm);
    emu_printf("MODLoad ok\n");
    MODUploadSamples(mod, SCSP_RAM);
    emu_printf("MODUploadSamples ok\n");
    vdp_sync_vblank_in_set(mod_handler, NULL);

    while (1)
        ;
}
#else
#define INCBIN_STYLE INCBIN_STYLE_SNAKE
#define INCBIN_PREFIX
#include "incbin.h"

INCBIN(m68kdriver, "/workspaces/loader_yaul/mikmod/libmikmod/saturn/driver.bin");

void midi_init()
{

    *(uint8_t *)(0x25B00400) = 0x02;

    smpc_smc_sndoff_call();
    smpc_smc_wait(false);

    memcpy(SCSP_RAM, m68kdriver_data, m68kdriver_size);

    smpc_smc_wait(false);
    smpc_smc_sndon_call();
}

#endif